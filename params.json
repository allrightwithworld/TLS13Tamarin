{"name":"Automated Analysis of TLS 1.3","tagline":"This is a Tamarin model of TLS 1.3","body":"# Automated Analysis of TLS 1.3: 0-RTT, Resumption and Delayed Authentication\r\n[Cas Cremers](https://www.cs.ox.ac.uk/people/cas.cremers), [Marko Horvat](https://www.cs.ox.ac.uk/people/marko.horvat), [Sam Scott](https://pure.royalholloway.ac.uk/portal/en/persons/sam-scott%2822345852-62ac-47be-8e56-84ac63717a5f%29.html), [Thyla van der Merwe](http://pure.rhul.ac.uk/portal/en/persons/thyla-van-der-merwe%289a30d837-2dd5-47ca-9db8-5f825b32023c%29.html)\r\n\r\nDownload the [technical paper](TODO: Add link to paper).\r\n\r\n## Introduction\r\n\r\nThe TLS protocol is used globally by millions of users on a daily basis,\r\nserving as the core building block for Internet security. The various flaws identified \r\nin TLS 1.2 and below, be they implementation- or specification-based, have prompted \r\nthe TLS Working Group to adopt an \"analysis-before-deployment\" design paradigm in \r\ndrafting the next version of the protocol. After a development process of \r\nmany months, the [TLS 1.3 specification](https://github.com/tlswg/tls13-spec)\r\nis nearly complete. \r\n\r\nIn the spirit of contributing \r\ntowards this new design philosophy, we model the TLS 1.3 specification using \r\nthe Tamarin prover, a tool for the automated analysis of security protocols. \r\nWe show that [revision 10 of the specification](https://tools.ietf.org/html/draft-ietf-tls-tls13-10) meets the goals of authenticated \r\nkey exchange for any combination of unilaterally and mutually authenticated\r\nhandshakes. \r\n\r\nBy extending our revision 10 model to incorporate the desired delayed client\r\nauthentication mechanism, we uncovered a potential attack in which an\r\nadversary is able to successfully impersonate a client during a\r\nPSK-resumption handshake.  Our attack highlighted the\r\nstrict necessity of including more information in the client signature contents. The IETF TLS Working Group updated\r\n[revision 11 of the TLS 1.3 specification draft](https://tools.ietf.org/html/draft-ietf-tls-tls13-11) based on our report.\r\n\r\nOur work provides the first supporting evidence for the security of\r\nseveral complex protocol mode interactions in TLS 1.3. Our formal \r\nmodel can be extended to future releases, \r\nthus being of long-lasting benefit.\r\nWe give a brief overview of our methodology in the following sections.\r\n\r\n## TLS 1.3\r\n\r\nThe new handshake modes of TLS 1.3 include a 1-RTT initial (EC)DHE mode, \r\na 0-RTT mode, a (Pre-Shared Key) PSK mode and a PSK-DHE mode. \r\nFor further details see the [TLS 1.3 specification draft](https://github.com/tlswg/tls13-spec).\r\n\r\n## Building a model\r\n\r\nFor our analysis, we use the Tamarin prover, a \r\ntool for the symbolic analysis of security protocols. Tamarin\r\nenables us to precisely specify and analyse the secrecy and\r\nauthentication properties of the various handshake modes. Furthermore,\r\nTamarin's multiset rewriting semantics are well-suited for modelling the\r\ncomplex transition system implied by the TLS 1.3 specification; the tool\r\nallows us to analyse the interaction of an unbounded number of concurrent\r\nTLS sessions. \r\nThe tool and further documentation can be\r\nfound on its \r\n[webpage](https://github.com/tamarin-prover/tamarin-prover). \r\n\r\nThe first step of our analysis is to construct an abstraction of the \r\nhandshake and record protocols which we then encode as Tamarin rules. Rules capture \r\nhonest-party and adversary actions alike. In the case of legitimate clients and servers, \r\nour constructed model rules generally correspond to all processing actions\r\nassociated with respective flights of messages. Our first client rule, for instance, \r\ncaptures a client generating and sending all necessary parameters as part of the first \r\nflight of an (EC)DHE handshake, as well as keeping track of them in the local client state.\r\nThis rule, `C_1`, is visible in the client state machine diagram below. The diagram \r\nrepresents the union of all the options that a client has in different executions. \r\n\r\nTODO: Include client state machine diagram here, with its caption. \r\n\r\n## Proving Stated Goals and Security Properties\r\n\r\nThe second step of the analysis involves encoding the desired security properties as \r\nTamarin lemmas. The goal of the TLS handshake protocol is \r\nto allow for unilateral or, optionally, mutual entity authentication of communicating\r\nparties, as well as to establish a shared secret that is unavailable to \r\neavesdroppers and adversaries who can place themselves in the middle of the \r\nconnection. The TLS record protocol is intended to provide confidentiality \r\nand integrity of application data. Hence, we encode the following properties as lemmas \r\n\r\n- unilateral authentication of the server (mandatory),\r\n- mutual authentication (optional) \r\n- confidentiality and perfect forward secrecy of session keys and\r\n- integrity of handshake messages.\r\n\r\nand aim to show that each property holds. \r\n\r\nWhile Tamarin can automatically construct proofs for simple protocols,\r\nits proof-finding heuristics are not yet strong enough to automatically\r\ngenerate full proofs for TLS 1.3.\r\nIn practice this meant that we augmented Tamarin's search with substantial manual effort: inspecting partial proofs and deducing appropriate hints (in the form of lemmas) to guide Tamarin's proof search.\r\n\r\nUsing this approach, we establish that revision 10 of the TLS 1.3 specification meets the goals of \r\nauthenticated key exchange in all possible combinations of \r\nclient, server, and adversary behaviours. \r\n\r\n## Attacking Client Authentication\r\n\r\nIn extending our revision 10 model to include the [delayed client authentication mechanism](https://www.ietf.org/proceedings/93/slides/slides-93-tls-2.pdf)\r\nas proposed by the TLS Working Group, we found an attack which violates client authentication, as an \r\nadversary can can impersonate a client when communicating with a server. The \r\nattack is similar to the [Triple Handshake attack](https://mitls.org/pages/attacks/3SHAKE) and works as follows: \r\n\r\nHandshake 1: Alice (the victim client) starts a connection with Charlie (the man-in-the-middle),\r\nand Charlie starts a connection with Bob (the targeted server). In both connections\r\na PSK is established. Alice shares `PSK_1` with Charlie and Charlie shares `PSK_2` \r\nwith Bob. \r\n\r\nTODO: Insert first poster attack section here. \r\n\r\nHandshake 2: Alice resumes a connection with Charlie using `PSK_1`. Alice generates \r\na random nonce `nc` and this is sent to Charlie. Charlie reuses this nonce\r\nto initiate a PSK-resumption handshake with Bob. Bob responds with a random \r\nnonce `ns`, and the server Finished message, computed using `PSK_2`. Charlie\r\nreuses `ns` and recomputes the Finished message for Alice using `PSK_1`. Alice returns \r\nher `Finished` message to Charlie who recomputes the Finished message for \r\nBob using `PSK_2`. At this point, Alice and Charlie share session keys\r\nderived from `PSK_1` and Charlie and Bob share session keys derived from \r\n`PSK_2`. \r\n\r\nTODO: Insert second poster attack section here. \r\n\r\nHandshake 3: Following resumption, Charlie attempts to make a request of Bob that \r\nrequires client authentication. Charlie is subsequently prompted for his \r\ncertificate and verification.  Charlie re-encrypts this request for Alice. \r\nTo compute the verification signature, Alice uses the `session_hash` value, which is \r\ndefined as the hash of all handshake messages \r\nexcluding the `Finished` messages. This session_hash value will match the one \r\nof Charlie and Bob, and hence Charlie can re-encrypt Alice's signature for Bob, \r\nwho accepts Alice's certificate and verification as valid authentication for Charlie. \r\n\r\nTODO: Insert third poster attack section here. \r\n\r\nThe attack is possible due to the lack of a strong binding between the client signature \r\nand the session for which that signature is intended. We note that revision 11 \r\nof the TLS 1.3 specification defines the client signature based on a Handshake Context \r\nvalue that includes the `Finished` message. This appears to address the attack as \r\nthe adversary would now need to force the Finished messages to match across \r\nthe two sessions. Although the inclusion of the `Finished` message in the Handshake \r\nContext message was suggested in [Pull Request #316](https://github.com/tlswg/tls13-spec/pull/316), the TLS Working \r\nGroup was unaware of the strict requirement to mitigate this attack.\r\n\r\n## Downloads\r\nDownload the [technical paper] (TODO: Add paper link).  \r\nDownload the Real World Crypto [slides](http://www.realworldcrypto.com/rwc2016/program/Automated%20Analysis%20of%20TLS%201.3%20RWC2016.pdf?attredirects=0&d=1). \r\n\r\n## Support \r\nPart of this work was completed whilst Sam Scott and Thyla van der Merwe were interns at Mozilla. We would like to thank Eric Rescorla, Martin Thomson and the TLS\r\nWorking Group for their invaluable inputs to this work by way of numerous\r\nclarifying conversations. \r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}