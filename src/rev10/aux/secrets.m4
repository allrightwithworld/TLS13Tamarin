changequote(<!,!>)dnl
changecom(<!/*!>,<!*/!>)dnl
dnl 
define(<!St_init!>,<!St_$1_$2_init(shift(shift($@)))!>)dnl
define(<!St_loop!>,<!L_St_$1_loop(shift($@))!>)dnl
define(<!St_init_KC!>,<!F_St_$1_$2_init_KC(shift(shift($@)))!>)dnl
define(<!St_init_PSK!>,<!F_St_$1_$2_init_PSK(shift(shift($@)))!>)dnl
define(<!ClientPSK!>, <!L_ClientPSK($@)!>)dnl
dnl
/*
    These are (probably) the most significant of the
    lemmas to prove. With these, many desirable properties
    follow in quite a straightforward way.

    STATUS: Needs work. Some automatic proofs, and some not
    proven at all.
*/
theory TLS_13_secrets
begin

include(tls13.m4i)
include(aux/invariants.m4i)
include(fresh_secret.m4i)
include(helpers.m4i)
include(dh_chal.m4i)
include(secrets.m4i)
include(secret_helpers.m4i)
include(psk_helpers.m4i)

include(axioms.m4i)

/* AUXILIARY LEMMAS */

/* Invariant lemmas from aux/invariants.m4i 
    proved in invariants.m4
 */
lemma_tid_invariant
lemma_one_start_per_tid
lemma_data_misuse
lemma_nonce_misuse
lemma_fresh_secret
lemma_ltk_invariant
lemma_pk_origin
lemma_fresh_psk
lemma_static_dh_invariant
lemma_psk_invariant
lemma_server_config_origin
dnl lemma_session_origin
/* end invariants */

/* Helper lemmas from aux/helpers.m4i */
lemma_key_deriv
lemma_psk_basic
lemma_forge_server_sig
lemma_forge_server_fin
lemma_dh_chal
lemma_ku_keys
/* end helpers */

/* Extra helper lemmas from aux/secret_helpers.m4i */
lemma_kc_origin
lemma_psk_dhe_es_basic
lemma_psk_auth
/* end secret helpers */

/*  Lemma es_basic
    Proof: manual

    One of the fundamental lemmas. Security of the 
    client's ephemeral secret.

    The proof is quite fiddly, but all the helper
    lemmas make it significantly easier.

    The proof mostly takes the following structure:
    dh_chal implies the adversary needs to learn ~a or ~b.
    If ~a, then simply unfold state and ~a is fresh.
    If ~b, we need to show this was generated by $S (
    and not $S.1 for example), which either comes from 
    the signature or the psk_auth lemma.

    Edge cases are PSK_DHE, which the specialised lemma deals with,
    or PSK, which is easier due to psk_basic.

    Seems like this could be automated.

*/
lemma_es_basic

/*  Lemma: ss_basic
    Proof: automatic, heuristic S

    The static secret variant of es_basic

    Proof is fairly straightforward. In cases where the ss 
    is the same as the es, then the proof is immediate.

    Otherwise, we either use the kc_origin or psk_basic
    to get an immediate inductive step.
*/
lemma_ss_basic

// from aux/helpers.m4i
lemma_forge_client_sig

// from aux/psk_helpers.m4i
lemma_psk_helper
lemma_authenticated_psk

/*  Lemma es_mutual
    Proof: unproven.

    One of the fundamental lemmas. Security of the 
    server's ephemeral secret.

    This is a lot trickier than the unilateral/client 
    scenario. This is due to the fact that a server
    can authenticate after multiple unauthenticated
    sessions. 

*/
lemma_es_mutual

/*  Lemma ss_mutual
    Proof: unproven.

    As above.
*/
lemma_ss_mutual

end